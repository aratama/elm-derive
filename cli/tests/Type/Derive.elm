module Type.Derive exposing (..)

-- This module is generated by elm-derive, do not edit this manually

import Array
import Dict
import Html
import Html.Attributes
import Json.Decode
import Json.Encode
import Random
import Set
import Type exposing (..)


compareTodoList : TodoList -> (TodoList -> Order)
compareTodoList =
    \lhs0 rhs0 ->
        case compareList compareTask lhs0.tasks rhs0.tasks of
            EQ ->
                case compare lhs0.field rhs0.field of
                    EQ ->
                        case compare lhs0.uid rhs0.uid of
                            EQ ->
                                case compare lhs0.visibility rhs0.visibility of
                                    EQ ->
                                        EQ

                                    o3 ->
                                        o3

                            o2 ->
                                o2

                    o1 ->
                        o1

            o0 ->
                o0


compareTask : Task -> (Task -> Order)
compareTask =
    \lhs0 rhs0 ->
        case compare lhs0.description rhs0.description of
            EQ ->
                case compareBool lhs0.completed rhs0.completed of
                    EQ ->
                        case compareMaybe compare lhs0.edits rhs0.edits of
                            EQ ->
                                case compare lhs0.id rhs0.id of
                                    EQ ->
                                        EQ

                                    o3 ->
                                        o3

                            o2 ->
                                o2

                    o1 ->
                        o1

            o0 ->
                o0


compareTree : Tree -> (Tree -> Order)
compareTree lhs rhs =
    case ( lhs, rhs ) of
        ( Leaf la, Leaf ra ) ->
            "0" :: List.concat [ compare a ]

        ( Branch la lb, Branch ra rb ) ->
            "1" :: List.concat [ compareTree a, compareTree b ]


compareColor : Color -> (Color -> Order)
compareColor lhs rhs =
    case ( lhs, rhs ) of
        ( Red, Red ) ->
            "0" :: List.concat []

        ( Green, Green ) ->
            "1" :: List.concat []

        ( Blue, Blue ) ->
            "2" :: List.concat []


compareVector : Vector -> (Vector -> Order)
compareVector lhs rhs =
    case ( lhs, rhs ) of
        ( Vector la, Vector ra ) ->
            "0"
                :: List.concat
                    [ (\lhs0 rhs0 ->
                        case compare lhs0.x rhs0.x of
                            EQ ->
                                case compare lhs0.y rhs0.y of
                                    EQ ->
                                        EQ

                                    o1 ->
                                        o1

                            o0 ->
                                o0
                      )
                        a
                    ]


compareGrid : Grid -> (Grid -> Order)
compareGrid =
    compareList (compareList compare)


compareDictionary : Dictionary -> (Dictionary -> Order)
compareDictionary =
    compareDict compare


compareEmptyRecord : EmptyRecord -> (EmptyRecord -> Order)
compareEmptyRecord =
    \lhs0 rhs0 -> EQ


comparePair : Pair -> (Pair -> Order)
comparePair =
    compareTuple compare compare


compareCharType : CharType -> (CharType -> Order)
compareCharType =
    compare


compareUnitType : UnitType -> (UnitType -> Order)
compareUnitType =
    EQ


compareNestedRecord : NestedRecord -> (NestedRecord -> Order)
compareNestedRecord =
    \lhs0 rhs0 ->
        case
            (\lhs1 rhs1 ->
                case
                    (\lhs2 rhs2 ->
                        case
                            (\lhs3 rhs3 ->
                                case
                                    (\lhs4 rhs4 ->
                                        case compare lhs4.e rhs4.e of
                                            EQ ->
                                                EQ

                                            o0 ->
                                                o0
                                    )
                                        lhs3.d
                                        rhs3.d
                                of
                                    EQ ->
                                        EQ

                                    o0 ->
                                        o0
                            )
                                lhs2.c
                                rhs2.c
                        of
                            EQ ->
                                EQ

                            o0 ->
                                o0
                    )
                        lhs1.b
                        rhs1.b
                of
                    EQ ->
                        EQ

                    o0 ->
                        o0
            )
                lhs0.a
                rhs0.a
        of
            EQ ->
                EQ

            o0 ->
                o0


compareArrayType : ArrayType -> (ArrayType -> Order)
compareArrayType =
    compareArray compare


compareSetType : SetType -> (SetType -> Order)
compareSetType =
    compareSet compare


compareResultType : ResultType -> (ResultType -> Order)
compareResultType =
    compareResult compare compare


viewTodoList : TodoList -> Html.Html msg
viewTodoList =
    \value0 -> Html.table [] [ Html.tbody [] [ Html.tr [] [ Html.td [] [ Html.text "tasks" ], Html.td [] [ viewList viewTask value0.tasks ] ], Html.tr [] [ Html.td [] [ Html.text "field" ], Html.td [] [ viewString value0.field ] ], Html.tr [] [ Html.td [] [ Html.text "uid" ], Html.td [] [ viewInt value0.uid ] ], Html.tr [] [ Html.td [] [ Html.text "visibility" ], Html.td [] [ viewString value0.visibility ] ] ] ]


viewTask : Task -> Html.Html msg
viewTask =
    \value0 -> Html.table [] [ Html.tbody [] [ Html.tr [] [ Html.td [] [ Html.text "description" ], Html.td [] [ viewString value0.description ] ], Html.tr [] [ Html.td [] [ Html.text "completed" ], Html.td [] [ viewBool value0.completed ] ], Html.tr [] [ Html.td [] [ Html.text "edits" ], Html.td [] [ viewMaybe viewString value0.edits ] ], Html.tr [] [ Html.td [] [ Html.text "id" ], Html.td [] [ viewInt value0.id ] ] ] ]


viewTree : Tree -> Html.Html msg
viewTree =
    \customTypeValue ->
        case customTypeValue of
            Leaf a ->
                Html.table [] [ Html.tr [] [ viewString a ] ]

            Branch a b ->
                Html.table [] [ Html.tr [] [ viewTree a ], Html.tr [] [ viewTree b ] ]


viewColor : Color -> Html.Html msg
viewColor =
    \customTypeValue ->
        case customTypeValue of
            Red ->
                Html.table [] []

            Green ->
                Html.table [] []

            Blue ->
                Html.table [] []


viewVector : Vector -> Html.Html msg
viewVector =
    \customTypeValue ->
        case customTypeValue of
            Vector a ->
                Html.table [] [ Html.tr [] [ (\value0 -> Html.table [] [ Html.tbody [] [ Html.tr [] [ Html.td [] [ Html.text "x" ], Html.td [] [ viewFloat value0.x ] ], Html.tr [] [ Html.td [] [ Html.text "y" ], Html.td [] [ viewFloat value0.y ] ] ] ]) a ] ]


viewGrid : Grid -> Html.Html msg
viewGrid =
    viewList (viewList viewInt)


viewDictionary : Dictionary -> Html.Html msg
viewDictionary =
    viewDict viewInt


viewEmptyRecord : EmptyRecord -> Html.Html msg
viewEmptyRecord =
    \value0 -> Html.table [] [ Html.tbody [] [] ]


viewPair : Pair -> Html.Html msg
viewPair =
    viewTuple viewInt viewString


viewCharType : CharType -> Html.Html msg
viewCharType =
    viewChar


viewUnitType : UnitType -> Html.Html msg
viewUnitType =
    \() -> Html.div [] [ Html.text "" ]


viewNestedRecord : NestedRecord -> Html.Html msg
viewNestedRecord =
    \value0 -> Html.table [] [ Html.tbody [] [ Html.tr [] [ Html.td [] [ Html.text "a" ], Html.td [] [ (\value1 -> Html.table [] [ Html.tbody [] [ Html.tr [] [ Html.td [] [ Html.text "b" ], Html.td [] [ (\value2 -> Html.table [] [ Html.tbody [] [ Html.tr [] [ Html.td [] [ Html.text "c" ], Html.td [] [ (\value3 -> Html.table [] [ Html.tbody [] [ Html.tr [] [ Html.td [] [ Html.text "d" ], Html.td [] [ (\value4 -> Html.table [] [ Html.tbody [] [ Html.tr [] [ Html.td [] [ Html.text "e" ], Html.td [] [ viewString value4.e ] ] ] ]) value3.d ] ] ] ]) value2.c ] ] ] ]) value1.b ] ] ] ]) value0.a ] ] ] ]


viewArrayType : ArrayType -> Html.Html msg
viewArrayType =
    viewArray viewString


viewSetType : SetType -> Html.Html msg
viewSetType =
    viewSet viewString


viewResultType : ResultType -> Html.Html msg
viewResultType =
    viewResult viewString viewInt


encodeTodoList : TodoList -> Json.Encode.Value
encodeTodoList =
    \value0 -> Json.Encode.object [ ( "tasks", Json.Encode.list encodeTask value0.tasks ), ( "field", Json.Encode.string value0.field ), ( "uid", Json.Encode.int value0.uid ), ( "visibility", Json.Encode.string value0.visibility ) ]


encodeTask : Task -> Json.Encode.Value
encodeTask =
    \value0 -> Json.Encode.object [ ( "description", Json.Encode.string value0.description ), ( "completed", Json.Encode.bool value0.completed ), ( "edits", encodeMaybe Json.Encode.string value0.edits ), ( "id", Json.Encode.int value0.id ) ]


encodeTree : Tree -> Json.Encode.Value
encodeTree val =
    case val of
        Leaf a ->
            Json.Encode.object [ ( "tag", Json.Encode.string "Leaf" ), ( "a", Json.Encode.string a ) ]

        Branch a b ->
            Json.Encode.object [ ( "tag", Json.Encode.string "Branch" ), ( "a", encodeTree a ), ( "b", encodeTree b ) ]


encodeColor : Color -> Json.Encode.Value
encodeColor val =
    case val of
        Red ->
            Json.Encode.object [ ( "tag", Json.Encode.string "Red" ) ]

        Green ->
            Json.Encode.object [ ( "tag", Json.Encode.string "Green" ) ]

        Blue ->
            Json.Encode.object [ ( "tag", Json.Encode.string "Blue" ) ]


encodeVector : Vector -> Json.Encode.Value
encodeVector val =
    case val of
        Vector a ->
            Json.Encode.object [ ( "tag", Json.Encode.string "Vector" ), ( "a", (\value0 -> Json.Encode.object [ ( "x", Json.Encode.float value0.x ), ( "y", Json.Encode.float value0.y ) ]) a ) ]


encodeGrid : Grid -> Json.Encode.Value
encodeGrid =
    Json.Encode.list (Json.Encode.list Json.Encode.int)


encodeDictionary : Dictionary -> Json.Encode.Value
encodeDictionary =
    Json.Encode.dict Basics.identity Json.Encode.int


encodeEmptyRecord : EmptyRecord -> Json.Encode.Value
encodeEmptyRecord =
    \value0 -> Json.Encode.object []


encodePair : Pair -> Json.Encode.Value
encodePair =
    \( fst, snd ) -> Json.Encode.list Basics.identity [ Json.Encode.int fst, Json.Encode.string snd ]


encodeCharType : CharType -> Json.Encode.Value
encodeCharType =
    encodeChar


encodeUnitType : UnitType -> Json.Encode.Value
encodeUnitType =
    \() -> Json.Encode.list Basics.identity []


encodeNestedRecord : NestedRecord -> Json.Encode.Value
encodeNestedRecord =
    \value0 -> Json.Encode.object [ ( "a", (\value1 -> Json.Encode.object [ ( "b", (\value2 -> Json.Encode.object [ ( "c", (\value3 -> Json.Encode.object [ ( "d", (\value4 -> Json.Encode.object [ ( "e", Json.Encode.string value4.e ) ]) value3.d ) ]) value2.c ) ]) value1.b ) ]) value0.a ) ]


encodeArrayType : ArrayType -> Json.Encode.Value
encodeArrayType =
    Json.Encode.array Json.Encode.string


encodeSetType : SetType -> Json.Encode.Value
encodeSetType =
    Json.Encode.set Json.Encode.string


encodeResultType : ResultType -> Json.Encode.Value
encodeResultType =
    encodeResult Json.Encode.string Json.Encode.int


decodeTodoList : Json.Decode.Decoder TodoList
decodeTodoList =
    Json.Decode.map4 TodoList (Json.Decode.field "tasks" (Json.Decode.list decodeTask)) (Json.Decode.field "field" Json.Decode.string) (Json.Decode.field "uid" Json.Decode.int) (Json.Decode.field "visibility" Json.Decode.string)


decodeTask : Json.Decode.Decoder Task
decodeTask =
    Json.Decode.map4 Task (Json.Decode.field "description" Json.Decode.string) (Json.Decode.field "completed" Json.Decode.bool) (Json.Decode.field "edits" (Json.Decode.maybe Json.Decode.string)) (Json.Decode.field "id" Json.Decode.int)


decodeTree : Json.Decode.Decoder Tree
decodeTree =
    Json.Decode.andThen
        (\tag ->
            case tag of
                "Leaf" ->
                    Json.Decode.map Leaf (Json.Decode.field "a" Json.Decode.string)

                "Branch" ->
                    Json.Decode.map2 Branch (Json.Decode.field "a" decodeTree) (Json.Decode.field "b" decodeTree)

                _ ->
                    Json.Decode.fail ("Unexpected tag name: " ++ tag)
        )
        (Json.Decode.field "tag" Json.Decode.string)


decodeColor : Json.Decode.Decoder Color
decodeColor =
    Json.Decode.andThen
        (\tag ->
            case tag of
                "Red" ->
                    Json.Decode.succeed Red

                "Green" ->
                    Json.Decode.succeed Green

                "Blue" ->
                    Json.Decode.succeed Blue

                _ ->
                    Json.Decode.fail ("Unexpected tag name: " ++ tag)
        )
        (Json.Decode.field "tag" Json.Decode.string)


decodeVector : Json.Decode.Decoder Vector
decodeVector =
    Json.Decode.andThen
        (\tag ->
            case tag of
                "Vector" ->
                    Json.Decode.map Vector (Json.Decode.field "a" (Json.Decode.map2 (\x y -> { x = x, y = y }) (Json.Decode.field "x" Json.Decode.float) (Json.Decode.field "y" Json.Decode.float)))

                _ ->
                    Json.Decode.fail ("Unexpected tag name: " ++ tag)
        )
        (Json.Decode.field "tag" Json.Decode.string)


decodeGrid : Json.Decode.Decoder Grid
decodeGrid =
    Json.Decode.list (Json.Decode.list Json.Decode.int)


decodeDictionary : Json.Decode.Decoder Dictionary
decodeDictionary =
    Json.Decode.dict Json.Decode.int


decodeEmptyRecord : Json.Decode.Decoder EmptyRecord
decodeEmptyRecord =
    Json.Decode.succeed {}


decodePair : Json.Decode.Decoder Pair
decodePair =
    Json.Decode.map2 Tuple.pair (Json.Decode.index 0 Json.Decode.int) (Json.Decode.index 1 Json.Decode.string)


decodeCharType : Json.Decode.Decoder CharType
decodeCharType =
    decodeChar


decodeUnitType : Json.Decode.Decoder UnitType
decodeUnitType =
    Json.Decode.succeed ()


decodeNestedRecord : Json.Decode.Decoder NestedRecord
decodeNestedRecord =
    Json.Decode.map NestedRecord (Json.Decode.field "a" (Json.Decode.map (\b -> { b = b }) (Json.Decode.field "b" (Json.Decode.map (\c -> { c = c }) (Json.Decode.field "c" (Json.Decode.map (\d -> { d = d }) (Json.Decode.field "d" (Json.Decode.map (\e -> { e = e }) (Json.Decode.field "e" Json.Decode.string)))))))))


decodeArrayType : Json.Decode.Decoder ArrayType
decodeArrayType =
    Json.Decode.array Json.Decode.string


decodeSetType : Json.Decode.Decoder SetType
decodeSetType =
    Json.Decode.map Set.fromList (Json.Decode.list Json.Decode.string)


decodeResultType : Json.Decode.Decoder ResultType
decodeResultType =
    decodeResult Json.Decode.string Json.Decode.int


randomTodoList : Random.Generator TodoList
randomTodoList =
    Random.map4 (\tasks field uid visibility -> { tasks = tasks, field = field, uid = uid, visibility = visibility }) (randomList randomTask) randomString randomInt randomString


randomTask : Random.Generator Task
randomTask =
    Random.map4 (\description completed edits id -> { description = description, completed = completed, edits = edits, id = id }) randomString randomBool (randomMaybe randomString) randomInt


randomTree : Random.Generator Tree
randomTree =
    let
        leaf () =
            Random.map Leaf randomString

        branch () =
            Random.map2 Branch randomTree randomTree
    in
    Random.andThen ((|>) ()) (Random.uniform leaf [ branch ])


randomColor : Random.Generator Color
randomColor =
    let
        red () =
            Random.constant Red

        green () =
            Random.constant Green

        blue () =
            Random.constant Blue
    in
    Random.andThen ((|>) ()) (Random.uniform red [ green, blue ])


randomVector : Random.Generator Vector
randomVector =
    let
        vector () =
            Random.map Vector (Random.map2 (\x y -> { x = x, y = y }) randomFloat randomFloat)
    in
    Random.andThen ((|>) ()) (Random.uniform vector [])


randomGrid : Random.Generator Grid
randomGrid =
    randomList (randomList randomInt)


randomDictionary : Random.Generator Dictionary
randomDictionary =
    randomDict randomInt


randomEmptyRecord : Random.Generator EmptyRecord
randomEmptyRecord =
    Random.constant {}


randomPair : Random.Generator Pair
randomPair =
    Random.pair randomInt randomString


randomCharType : Random.Generator CharType
randomCharType =
    randomChar


randomUnitType : Random.Generator UnitType
randomUnitType =
    Random.constant ()


randomNestedRecord : Random.Generator NestedRecord
randomNestedRecord =
    Random.map (\a -> { a = a }) (Random.map (\b -> { b = b }) (Random.map (\c -> { c = c }) (Random.map (\d -> { d = d }) (Random.map (\e -> { e = e }) randomString))))


randomArrayType : Random.Generator ArrayType
randomArrayType =
    randomArray randomString


randomSetType : Random.Generator SetType
randomSetType =
    randomSet randomString


randomResultType : Random.Generator ResultType
randomResultType =
    randomResult randomString randomInt


decodeChar : Json.Decode.Decoder Char
decodeChar =
    Json.Decode.andThen
        (\str ->
            case String.toList str of
                [ c ] ->
                    Json.Decode.succeed c

                _ ->
                    Json.Decode.fail "decodeChar: too many charactors for Char type"
        )
        Json.Decode.string


decodeAndMap : Json.Decode.Decoder a -> (Json.Decode.Decoder (a -> b) -> Json.Decode.Decoder b)
decodeAndMap =
    Json.Decode.map2 (|>)


decodeResult : Json.Decode.Decoder err -> (Json.Decode.Decoder ok -> Json.Decode.Decoder (Result err ok))
decodeResult errDecoder okDecoder =
    Json.Decode.andThen
        (\tag ->
            case tag of
                "Err" ->
                    Json.Decode.map Err (Json.Decode.field "a" errDecoder)

                "Ok" ->
                    Json.Decode.map Ok (Json.Decode.field "a" okDecoder)

                _ ->
                    Json.Decode.fail ("decodeResult: Invalid tag name: " ++ tag)
        )
        (Json.Decode.field "tag" Json.Decode.string)


encodeMaybe : (a -> Json.Encode.Value) -> (Maybe a -> Json.Encode.Value)
encodeMaybe f encodeMaybeValue =
    case encodeMaybeValue of
        Nothing ->
            Json.Encode.null

        Just justValue ->
            f justValue


encodeChar : Char -> Json.Encode.Value
encodeChar value =
    Json.Encode.string (String.fromChar value)


encodeResult : (err -> Json.Encode.Value) -> ((ok -> Json.Encode.Value) -> (Result err ok -> Json.Encode.Value))
encodeResult errEncoder okEncoder value =
    case value of
        Err err ->
            Json.Encode.object [ ( "tag", Json.Encode.string "Err" ), ( "a", errEncoder err ) ]

        Ok ok ->
            Json.Encode.object [ ( "tag", Json.Encode.string "Ok" ), ( "a", okEncoder ok ) ]


randomBool : Random.Generator Bool
randomBool =
    Random.uniform True [ False ]


randomInt : Random.Generator Int
randomInt =
    Random.int 0 100


randomString : Random.Generator String
randomString =
    Random.uniform "Alpha" [ "Bravo", "Charlie", "Delta", "Echo", "Foxtrot", "Golf", "Hotel", "India", "Juliet ", "Kilo", "Lima", "Mike", "Novenber", "Oscar", "Papa", "Quebec", "Romeo", "Sierra", "Tango", "Uniform", "Victor", "Whiskey", "X-ray", "Yankee", "Zulu" ]


randomChar : Random.Generator Char
randomChar =
    Random.uniform 'a' (String.toList "bcdefghijklmnopqlstuvwxyz")


randomFloat : Random.Generator Float
randomFloat =
    Random.float 0 1


randomList : Random.Generator a -> Random.Generator (List a)
randomList gen =
    Random.andThen (\n -> Random.list (3 + n) gen) (Random.int 0 7)


randomArray : Random.Generator a -> Random.Generator (Array.Array a)
randomArray gen =
    Random.map Array.fromList (randomList gen)


randomSet : Random.Generator comparable -> Random.Generator (Set.Set comparable)
randomSet gen =
    Random.map Set.fromList (randomList gen)


randomMaybe : Random.Generator a -> Random.Generator (Maybe a)
randomMaybe gen =
    Random.andThen (\n -> Random.uniform Nothing [ Just n ]) gen


randomResult : Random.Generator err -> (Random.Generator ok -> Random.Generator (Result err ok))
randomResult errGen okGen =
    Random.andThen identity (Random.uniform (Random.map Err errGen) [ Random.map Ok okGen ])


randomDict : Random.Generator a -> Random.Generator (Dict.Dict String a)
randomDict gen =
    Random.map Dict.fromList (randomList (Random.map2 (\k v -> ( k, v )) randomString gen))


viewList : (a -> Html.Html msg) -> (List a -> Html.Html msg)
viewList f xs =
    Html.table []
        [ Html.caption [] [ Html.text "List" ]
        , Html.tbody [] (List.indexedMap (\i x -> Html.tr [] [ Html.td [] [ Html.text <| String.fromInt i ], Html.td [] [ f x ] ]) xs)
        ]


viewArray : (a -> Html.Html msg) -> (Array.Array a -> Html.Html msg)
viewArray f xs =
    viewList f (Array.toList xs)


viewSet : (a -> Html.Html msg) -> (Set.Set a -> Html.Html msg)
viewSet f xs =
    viewList f (Set.toList xs)


viewMaybe : (a -> Html.Html msg) -> (Maybe a -> Html.Html msg)
viewMaybe f m =
    case m of
        Nothing ->
            Html.div [ Html.Attributes.class "elm-derive-maybe" ] [ Html.text "null" ]

        Just a ->
            Html.div [ Html.Attributes.class "elm-derive-maybe" ] [ f a ]


viewResult : (err -> Html.Html msg) -> ((ok -> Html.Html msg) -> (Result err ok -> Html.Html msg))
viewResult errView okView value =
    case value of
        Err err ->
            Html.div [ Html.Attributes.class "elm-derive-result" ] [ errView err ]

        Ok ok ->
            Html.div [ Html.Attributes.class "elm-derive-result" ] [ okView ok ]


viewBool : Bool -> Html.Html msg
viewBool value =
    Html.div [ Html.Attributes.class "elm-derive-primitive" ]
        [ Html.text <|
            if value then
                "True"

            else
                "False"
        ]


viewInt : Int -> Html.Html msg
viewInt value =
    Html.div [ Html.Attributes.class "elm-derive-primitive" ] [ Html.text <| String.fromInt value ]


viewString : String -> Html.Html msg
viewString value =
    Html.div [ Html.Attributes.class "elm-derive-primitive" ] [ Html.text value ]


viewChar : Char -> Html.Html msg
viewChar value =
    Html.div [ Html.Attributes.class "elm-derive-primitive" ] [ Html.text <| String.fromChar value ]


viewFloat : Float -> Html.Html msg
viewFloat value =
    Html.div [ Html.Attributes.class "elm-derive-primitive" ] [ Html.text <| String.fromFloat value ]


viewDict : (a -> Html.Html msg) -> (Dict.Dict String a -> Html.Html msg)
viewDict f dict =
    Html.table []
        [ Html.caption [] [ Html.text "Dict" ]
        , Html.tbody [] (List.map (\( k, v ) -> Html.tr [] [ Html.td [] [ Html.text k ], Html.td [] [ f v ] ]) (Dict.toList dict))
        ]


viewTuple : (a -> Html.Html msg) -> ((b -> Html.Html msg) -> (( a, b ) -> Html.Html msg))
viewTuple fa fb ( a, b ) =
    Html.table []
        [ Html.caption [] [ Html.text "Dict" ]
        , Html.tbody []
            [ Html.tr []
                [ Html.td [] [ Html.text "fst" ]
                , Html.td [] [ fa a ]
                ]
            , Html.tr []
                [ Html.td [] [ Html.text "snd" ]
                , Html.td [] [ fb b ]
                ]
            ]
        ]


compareList : (a -> (a -> Order)) -> (List a -> (List a -> Order))
compareList f lhs rhs =
    case ( lhs, rhs ) of
        ( [], [] ) ->
            EQ

        ( x :: xs, [] ) ->
            GT

        ( [], y :: ys ) ->
            LT

        ( x :: xs, y :: ys ) ->
            case f x y of
                EQ ->
                    compareList f xs ys

                ret ->
                    ret


compareMaybe : (a -> (a -> Order)) -> (Maybe a -> (Maybe a -> Order))
compareMaybe f lhs rhs =
    case ( lhs, rhs ) of
        ( Nothing, Nothing ) ->
            EQ

        ( Nothing, Just _ ) ->
            GT

        ( Just _, Nothing ) ->
            LT

        ( Just x, Just y ) ->
            f x y


compareBool _ _ =
    EQ


compareSet _ _ _ =
    EQ


compareArray _ _ _ =
    EQ


compareDict _ _ _ =
    EQ


compareTuple _ _ _ _ =
    EQ


compareResult _ _ _ _ =
    EQ
