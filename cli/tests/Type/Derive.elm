module Type.Derive exposing (..)
-- This module is generated by elm-derive, do not edit this manually
import Dict  
import Html  
import Html.Attributes  
import Json.Encode  
import Json.Decode  
import Random  
import Type  exposing (..)

viewTodoList : TodoList -> Html.Html msg
viewTodoList  =
    (\value0 -> Html.table [] [Html.tbody [] [Html.tr [] [Html.td [] [Html.text "tasks"], Html.td [] [(viewList viewTask) value0.tasks]], Html.tr [] [Html.td [] [Html.text "field"], Html.td [] [viewString value0.field]], Html.tr [] [Html.td [] [Html.text "uid"], Html.td [] [viewInt value0.uid]], Html.tr [] [Html.td [] [Html.text "visibility"], Html.td [] [viewString value0.visibility]]]])

viewTask : Task -> Html.Html msg
viewTask  =
    (\value0 -> Html.table [] [Html.tbody [] [Html.tr [] [Html.td [] [Html.text "description"], Html.td [] [viewString value0.description]], Html.tr [] [Html.td [] [Html.text "completed"], Html.td [] [viewBool value0.completed]], Html.tr [] [Html.td [] [Html.text "edits"], Html.td [] [(viewMaybe viewString) value0.edits]], Html.tr [] [Html.td [] [Html.text "id"], Html.td [] [viewInt value0.id]]]])

viewTree : Tree -> Html.Html msg
viewTree  =
    (\customTypeValue -> case customTypeValue of
      Leaf a ->
        Html.table [] [Html.tr [] [viewString a]]
      Branch a b ->
        Html.table [] [Html.tr [] [viewTree a], Html.tr [] [viewTree b]])

viewColor : Color -> Html.Html msg
viewColor  =
    (\customTypeValue -> case customTypeValue of
      Red  ->
        Html.table [] []
      Green  ->
        Html.table [] []
      Blue  ->
        Html.table [] [])

viewVector : Vector -> Html.Html msg
viewVector  =
    (\customTypeValue -> case customTypeValue of
      Vector a ->
        Html.table [] [Html.tr [] [(\value0 -> Html.table [] [Html.tbody [] [Html.tr [] [Html.td [] [Html.text "x"], Html.td [] [viewFloat value0.x]], Html.tr [] [Html.td [] [Html.text "y"], Html.td [] [viewFloat value0.y]]]]) a]])

viewGrid : Grid -> Html.Html msg
viewGrid  =
    (viewList (viewList viewInt))

viewDictionary : Dictionary -> Html.Html msg
viewDictionary  =
    (viewDict viewInt)

viewEmptyRecord : EmptyRecord -> Html.Html msg
viewEmptyRecord  =
    (\value0 -> Html.table [] [Html.tbody [] []])

viewPair : Pair -> Html.Html msg
viewPair  =
    (viewTuple viewInt viewString)

viewCharType : CharType -> Html.Html msg
viewCharType  =
    viewChar

viewUnitType : UnitType -> Html.Html msg
viewUnitType  =
    (\() -> Html.div [] [Html.text ""])

viewNestedRecord : NestedRecord -> Html.Html msg
viewNestedRecord  =
    (\value0 -> Html.table [] [Html.tbody [] [Html.tr [] [Html.td [] [Html.text "a"], Html.td [] [(\value1 -> Html.table [] [Html.tbody [] [Html.tr [] [Html.td [] [Html.text "b"], Html.td [] [(\value2 -> Html.table [] [Html.tbody [] [Html.tr [] [Html.td [] [Html.text "c"], Html.td [] [(\value3 -> Html.table [] [Html.tbody [] [Html.tr [] [Html.td [] [Html.text "d"], Html.td [] [(\value4 -> Html.table [] [Html.tbody [] [Html.tr [] [Html.td [] [Html.text "e"], Html.td [] [viewString value4.e]]]]) value3.d]]]]) value2.c]]]]) value1.b]]]]) value0.a]]]])

encodeTodoList : TodoList -> Json.Encode.Value
encodeTodoList  =
    (\value0 -> Json.Encode.object [("tasks", (Json.Encode.list encodeTask) value0.tasks), ("field", Json.Encode.string value0.field), ("uid", Json.Encode.int value0.uid), ("visibility", Json.Encode.string value0.visibility)])

encodeTask : Task -> Json.Encode.Value
encodeTask  =
    (\value0 -> Json.Encode.object [("description", Json.Encode.string value0.description), ("completed", Json.Encode.bool value0.completed), ("edits", (encodeMaybe Json.Encode.string) value0.edits), ("id", Json.Encode.int value0.id)])

encodeTree : Tree -> Json.Encode.Value
encodeTree val =
    case val of
      Leaf a ->
        Json.Encode.object [("tag", Json.Encode.string "Leaf"), ("a", Json.Encode.string a)]
      Branch a b ->
        Json.Encode.object [("tag", Json.Encode.string "Branch"), ("a", encodeTree a), ("b", encodeTree b)]

encodeColor : Color -> Json.Encode.Value
encodeColor val =
    case val of
      Red  ->
        Json.Encode.object [("tag", Json.Encode.string "Red")]
      Green  ->
        Json.Encode.object [("tag", Json.Encode.string "Green")]
      Blue  ->
        Json.Encode.object [("tag", Json.Encode.string "Blue")]

encodeVector : Vector -> Json.Encode.Value
encodeVector val =
    case val of
      Vector a ->
        Json.Encode.object [("tag", Json.Encode.string "Vector"), ("a", (\value0 -> Json.Encode.object [("x", Json.Encode.float value0.x), ("y", Json.Encode.float value0.y)]) a)]

encodeGrid : Grid -> Json.Encode.Value
encodeGrid  =
    (Json.Encode.list (Json.Encode.list Json.Encode.int))

encodeDictionary : Dictionary -> Json.Encode.Value
encodeDictionary  =
    (Json.Encode.dict identity Json.Encode.int)

encodeEmptyRecord : EmptyRecord -> Json.Encode.Value
encodeEmptyRecord  =
    (\value0 -> Json.Encode.object [])

encodePair : Pair -> Json.Encode.Value
encodePair  =
    (\(fst, snd) -> Json.Encode.list identity [(Json.Encode.int fst), (Json.Encode.string snd)])

encodeCharType : CharType -> Json.Encode.Value
encodeCharType  =
    encodeChar

encodeUnitType : UnitType -> Json.Encode.Value
encodeUnitType  =
    (\() -> Json.Encode.object [])

encodeNestedRecord : NestedRecord -> Json.Encode.Value
encodeNestedRecord  =
    (\value0 -> Json.Encode.object [("a", (\value1 -> Json.Encode.object [("b", (\value2 -> Json.Encode.object [("c", (\value3 -> Json.Encode.object [("d", (\value4 -> Json.Encode.object [("e", Json.Encode.string value4.e)]) value3.d)]) value2.c)]) value1.b)]) value0.a)])

decodeTodoList : Json.Decode.Decoder TodoList
decodeTodoList  =
    Json.Decode.map4 TodoList (Json.Decode.field "tasks" ((Json.Decode.list decodeTask))) (Json.Decode.field "field" (Json.Decode.string)) (Json.Decode.field "uid" (Json.Decode.int)) (Json.Decode.field "visibility" (Json.Decode.string))

decodeTask : Json.Decode.Decoder Task
decodeTask  =
    Json.Decode.map4 Task (Json.Decode.field "description" (Json.Decode.string)) (Json.Decode.field "completed" (Json.Decode.bool)) (Json.Decode.field "edits" ((Json.Decode.maybe Json.Decode.string))) (Json.Decode.field "id" (Json.Decode.int))

decodeTree : Json.Decode.Decoder Tree
decodeTree  =
    Json.Decode.andThen (\tag -> case tag of
      "Leaf" ->
        ((Json.Decode.map Leaf (Json.Decode.field "a" Json.Decode.string)))
      "Branch" ->
        ((Json.Decode.map2 Branch (Json.Decode.field "a" decodeTree) (Json.Decode.field "b" decodeTree)))
      _ ->
        Json.Decode.fail ("Unexpected tag name: " ++ tag)) (Json.Decode.field "tag" Json.Decode.string)

decodeColor : Json.Decode.Decoder Color
decodeColor  =
    Json.Decode.andThen (\tag -> case tag of
      "Red" ->
        ((Json.Decode.succeed Red))
      "Green" ->
        ((Json.Decode.succeed Green))
      "Blue" ->
        ((Json.Decode.succeed Blue))
      _ ->
        Json.Decode.fail ("Unexpected tag name: " ++ tag)) (Json.Decode.field "tag" Json.Decode.string)

decodeVector : Json.Decode.Decoder Vector
decodeVector  =
    Json.Decode.andThen (\tag -> case tag of
      "Vector" ->
        ((Json.Decode.map Vector (Json.Decode.field "a" (Json.Decode.map2 (\x y -> {x = x, y = y}) (Json.Decode.field "x" Json.Decode.float) (Json.Decode.field "y" Json.Decode.float)))))
      _ ->
        Json.Decode.fail ("Unexpected tag name: " ++ tag)) (Json.Decode.field "tag" Json.Decode.string)

decodeGrid : Json.Decode.Decoder Grid
decodeGrid  =
    (Json.Decode.list (Json.Decode.list Json.Decode.int))

decodeDictionary : Json.Decode.Decoder Dictionary
decodeDictionary  =
    (Json.Decode.dict Json.Decode.int)

decodeEmptyRecord : Json.Decode.Decoder EmptyRecord
decodeEmptyRecord  =
    Json.Decode.succeed {}

decodePair : Json.Decode.Decoder Pair
decodePair  =
    (Json.Decode.map2 Tuple.pair (Json.Decode.index 0 Json.Decode.int) (Json.Decode.index 1 Json.Decode.string))

decodeCharType : Json.Decode.Decoder CharType
decodeCharType  =
    decodeChar

decodeUnitType : Json.Decode.Decoder UnitType
decodeUnitType  =
    (Json.Decode.succeed ())

decodeNestedRecord : Json.Decode.Decoder NestedRecord
decodeNestedRecord  =
    Json.Decode.map NestedRecord (Json.Decode.field "a" ((Json.Decode.map (\b -> {b = b}) (Json.Decode.field "b" (Json.Decode.map (\c -> {c = c}) (Json.Decode.field "c" (Json.Decode.map (\d -> {d = d}) (Json.Decode.field "d" (Json.Decode.map (\e -> {e = e}) (Json.Decode.field "e" Json.Decode.string))))))))))

randomTodoList : Random.Generator TodoList
randomTodoList  =
    (Random.map4 (\tasks field uid visibility -> {tasks = tasks, field = field, uid = uid, visibility = visibility}) (randomList randomTask) randomString randomInt randomString)

randomTask : Random.Generator Task
randomTask  =
    (Random.map4 (\description completed edits id -> {description = description, completed = completed, edits = edits, id = id}) randomString randomBool (randomMaybe randomString) randomInt)

randomTree : Random.Generator Tree
randomTree  =
    let
      
      
      leaf () =
          Random.map Leaf randomString
      
      
      branch () =
          Random.map2 Branch randomTree randomTree
    in
      Random.andThen ((|>) ()) (Random.uniform leaf [branch])

randomColor : Random.Generator Color
randomColor  =
    let
      
      
      red () =
          Random.constant Red
      
      
      green () =
          Random.constant Green
      
      
      blue () =
          Random.constant Blue
    in
      Random.andThen ((|>) ()) (Random.uniform red [green, blue])

randomVector : Random.Generator Vector
randomVector  =
    let
      
      
      vector () =
          Random.map Vector (Random.map2 (\x y -> {x = x, y = y}) randomFloat randomFloat)
    in
      Random.andThen ((|>) ()) (Random.uniform vector [])

randomGrid : Random.Generator Grid
randomGrid  =
    (randomList (randomList randomInt))

randomDictionary : Random.Generator Dictionary
randomDictionary  =
    (randomDict randomInt)

randomEmptyRecord : Random.Generator EmptyRecord
randomEmptyRecord  =
    (Random.constant {})

randomPair : Random.Generator Pair
randomPair  =
    (Random.pair randomInt randomString)

randomCharType : Random.Generator CharType
randomCharType  =
    randomChar

randomUnitType : Random.Generator UnitType
randomUnitType  =
    (Random.constant ())

randomNestedRecord : Random.Generator NestedRecord
randomNestedRecord  =
    (Random.map (\a -> {a = a}) (Random.map (\b -> {b = b}) (Random.map (\c -> {c = c}) (Random.map (\d -> {d = d}) (Random.map (\e -> {e = e}) randomString)))))

decodeChar : Json.Decode.Decoder Char
decodeChar  =
    Json.Decode.andThen (\str -> case String.toList str of
      [c] ->
        Json.Decode.succeed c
      _ ->
        Json.Decode.fail "decodeChar: too many charactors for Char type")
     Json.Decode.string

encodeMaybe : (a -> Json.Encode.Value) -> (Maybe a -> Json.Encode.Value)
encodeMaybe f encodeMaybeValue =
    case encodeMaybeValue of
      Nothing  ->
        Json.Encode.null
      Just justValue ->
        f justValue

encodeChar : Char -> Json.Encode.Value
encodeChar value =
    Json.Encode.string (String.fromChar value)

randomBool : Random.Generator Bool
randomBool  =
    Random.uniform True [False]

randomInt : Random.Generator Int
randomInt  =
    Random.int 0 100

randomString : Random.Generator String
randomString  =
    Random.uniform "Alpha" ["Bravo", "Charlie", "Delta", "Echo", "Foxtrot", "Golf", "Hotel", "India", "Juliet ", "Kilo", "Lima", "Mike", "Novenber", "Oscar", "Papa", "Quebec", "Romeo", "Sierra", "Tango", "Uniform", "Victor", "Whiskey", "X-ray", "Yankee", "Zulu"]

randomChar : Random.Generator Char
randomChar  =
    Random.uniform 'a' (String.toList "bcdefghijklmnopqlstuvwxyz")

randomFloat : Random.Generator Float
randomFloat  =
    Random.float 0 1

randomList : Random.Generator a -> Random.Generator (List a)
randomList gen =
    Random.andThen (\n -> Random.list (3 + n) gen) (Random.int 0 7)

randomMaybe : Random.Generator a -> Random.Generator (Maybe a)
randomMaybe gen =
    Random.andThen (\n -> Random.uniform Nothing [Just n]) gen

randomDict : Random.Generator a -> Random.Generator (Dict.Dict String a)
randomDict gen =
    Random.map Dict.fromList (randomList (Random.map2 (\k v -> (k, v)) randomString gen))

viewList : (a -> Html.Html msg) -> (List a -> Html.Html msg)
viewList f xs =
    Html.table []
     [Html.caption [] [Html.text "List"]
    , Html.tbody [] (List.indexedMap (\i x -> Html.tr [] [Html.td [] [Html.text <| String.fromInt i], Html.td [] [f x]]) xs)]

viewMaybe : (a -> Html.Html msg) -> (Maybe a -> Html.Html msg)
viewMaybe f m =
    case m of
      Nothing  ->
        Html.div [Html.Attributes.class "elm-derive-maybe"] [Html.text "null"]
      Just a ->
        Html.div [Html.Attributes.class "elm-derive-maybe"] [f a]

viewBool : Bool -> Html.Html msg
viewBool value =
    Html.div [Html.Attributes.class "elm-derive-primitive"] [Html.text <| if value then
      "True"
    else
      "False"]

viewInt : Int -> Html.Html msg
viewInt value =
    Html.div [Html.Attributes.class "elm-derive-primitive"] [Html.text <| String.fromInt value]

viewString : String -> Html.Html msg
viewString value =
    Html.div [Html.Attributes.class "elm-derive-primitive"] [Html.text value]

viewChar : Char -> Html.Html msg
viewChar value =
    Html.div [Html.Attributes.class "elm-derive-primitive"] [Html.text <| String.fromChar value]

viewFloat : Float -> Html.Html msg
viewFloat value =
    Html.div [Html.Attributes.class "elm-derive-primitive"] [Html.text <| String.fromFloat value]

viewDict : (a -> Html.Html msg) -> (Dict.Dict String a -> Html.Html msg)
viewDict f dict =
    Html.table []
     [Html.caption [] [Html.text "Dict"]
    , Html.tbody [] (List.map (\(k, v) -> Html.tr [] [Html.td [] [Html.text k], Html.td [] [f v]]) (Dict.toList dict))]

viewTuple : (a -> Html.Html msg) -> ((b -> Html.Html msg) -> ((a, b) -> Html.Html msg))
viewTuple fa fb (a, b) =
    Html.table []
     [Html.caption [] [Html.text "Dict"]
    , Html.tbody []
     [Html.tr []
     [Html.td [] [Html.text "fst"]
    , Html.td [] [fa a]]
    , Html.tr []
     [Html.td [] [Html.text "snd"]
    , Html.td [] [fb b]]]]