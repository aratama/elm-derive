module Main exposing (main)

import Derive
import Derive.Util exposing (..)
import Dict exposing (Dict)
import Elm.Parser
import Elm.Processing
import Elm.RawFile exposing (RawFile)
import Elm.Writer
import Graph
import List.Extra as List
import Parser exposing (Problem(..))
import Parser.Extra
import Platform
import Port


headerComment : String
headerComment =
    "-- This module is generated by elm-derive, do not edit this manually"


type alias Flags =
    { target : String
    , encode : Bool
    , decode : Bool
    , random : Bool
    , html : Bool
    , ord : Bool
    }


type alias Model =
    { flags : Flags
    , requestingFiles : Dict String ()
    , files : Dict String RawFile
    }


type Msg
    = ReceiveFile { path : String, source : String }


main : Program Flags Model Msg
main =
    Platform.worker
        { init =
            \flags ->
                ( { flags = flags
                  , requestingFiles = Dict.singleton flags.target ()
                  , files = Dict.empty
                  }
                , Port.requestFile <| flags.target
                )
        , update = update
        , subscriptions = always <| Port.receiveFile ReceiveFile
        }


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        ReceiveFile { path, source } ->
            case Elm.Parser.parse source of
                Err err ->
                    ( model
                    , Port.exitWithError <| "Parse Error: " ++ (unlines <| List.map (Parser.Extra.deadEndToString source) err)
                    )

                Ok rawFile ->
                    let
                        moduleName =
                            path
                                |> String.dropRight (String.length ".elm")
                                |> String.replace "/" "."

                        model_ =
                            { model
                                | files = Dict.insert moduleName rawFile model.files
                                , requestingFiles = Dict.remove path model.requestingFiles
                            }
                    in
                    if Dict.isEmpty model_.requestingFiles then
                        let
                            targetModuleName =
                                model.flags.target
                                    |> String.dropRight (String.length ".elm")
                                    |> String.replace "/" "."
                        in
                        case Dict.get targetModuleName model_.files of
                            Nothing ->
                                ( model_, Port.exitWithError "Internal Error" )

                            Just targetRawFile ->
                                let
                                    file =
                                        Elm.Processing.process Elm.Processing.init targetRawFile

                                    result =
                                        Derive.generate model.flags file
                                in
                                case result of
                                    Err err ->
                                        ( model_, Port.exitWithError <| "Generation Error: " ++ String.join " " err )

                                    Ok generated ->
                                        ( model_
                                        , Cmd.batch
                                            [ Port.writeFile
                                                { path = String.replace "." "/" targetModuleName ++ "/Derive.elm"
                                                , source = Elm.Writer.write (Elm.Writer.writeFile generated)
                                                }
                                            , Port.exit ()
                                            ]
                                        )

                    else
                        ( model_, Cmd.none )
