module Derive.Web.Type.Derive exposing (..)
-- This module is generated by elm-derive, do not edit this manually
import Dict  
import Html  
import Html.Attributes  
import Json.Encode  
import Json.Decode  
import Random  
import Derive.Web.Type  exposing (..)

viewModel : Model -> Html.Html msg
viewModel  =
    (\value0 -> Html.table [] [Html.tbody [] [Html.tr [] [Html.td [] [Html.text "source"], Html.td [] [viewString value0.source]], Html.tr [] [Html.td [] [Html.text "encoderVisible"], Html.td [] [viewBool value0.encoderVisible]], Html.tr [] [Html.td [] [Html.text "decoderVisible"], Html.td [] [viewBool value0.decoderVisible]], Html.tr [] [Html.td [] [Html.text "loadStorageVisible"], Html.td [] [viewBool value0.loadStorageVisible]]]])

encodeModel : Model -> Json.Encode.Value
encodeModel  =
    (\value0 -> Json.Encode.object [("source", Json.Encode.string value0.source), ("encoderVisible", Json.Encode.bool value0.encoderVisible), ("decoderVisible", Json.Encode.bool value0.decoderVisible), ("loadStorageVisible", Json.Encode.bool value0.loadStorageVisible)])

decodeModel : Json.Decode.Decoder Model
decodeModel  =
    Json.Decode.map4 Model (Json.Decode.field "source" (Json.Decode.string)) (Json.Decode.field "encoderVisible" (Json.Decode.bool)) (Json.Decode.field "decoderVisible" (Json.Decode.bool)) (Json.Decode.field "loadStorageVisible" (Json.Decode.bool))

randomModel : Random.Generator Model
randomModel  =
    (Random.map4 (\source encoderVisible decoderVisible loadStorageVisible -> {source = source, encoderVisible = encoderVisible, decoderVisible = decoderVisible, loadStorageVisible = loadStorageVisible}) randomString randomBool randomBool randomBool)

decodeChar : Json.Decode.Decoder Char
decodeChar  =
    Json.Decode.andThen (\str -> case String.toList str of
      [c] ->
        Json.Decode.succeed c
      _ ->
        Json.Decode.fail "decodeChar: too many charactors for Char type")
     Json.Decode.string

encodeMaybe : (a -> Json.Encode.Value) -> (Maybe a -> Json.Encode.Value)
encodeMaybe f encodeMaybeValue =
    case encodeMaybeValue of
      Nothing  ->
        Json.Encode.null
      Just justValue ->
        f justValue

encodeChar : Char -> Json.Encode.Value
encodeChar value =
    Json.Encode.string (String.fromChar value)

randomBool : Random.Generator Bool
randomBool  =
    Random.uniform True [False]

randomInt : Random.Generator Int
randomInt  =
    Random.int 0 100

randomString : Random.Generator String
randomString  =
    Random.uniform "Alpha" ["Bravo", "Charlie", "Delta", "Echo", "Foxtrot", "Golf", "Hotel", "India", "Juliet ", "Kilo", "Lima", "Mike", "Novenber", "Oscar", "Papa", "Quebec", "Romeo", "Sierra", "Tango", "Uniform", "Victor", "Whiskey", "X-ray", "Yankee", "Zulu"]

randomChar : Random.Generator Char
randomChar  =
    Random.uniform 'a' (String.toList "bcdefghijklmnopqlstuvwxyz")

randomFloat : Random.Generator Float
randomFloat  =
    Random.float 0 1

randomList : Random.Generator a -> Random.Generator (List a)
randomList gen =
    Random.andThen (\n -> Random.list (3 + n) gen) (Random.int 0 7)

randomMaybe : Random.Generator a -> Random.Generator (Maybe a)
randomMaybe gen =
    Random.andThen (\n -> Random.uniform Nothing [Just n]) gen

randomDict : Random.Generator a -> Random.Generator (Dict.Dict String a)
randomDict gen =
    Random.map Dict.fromList (randomList (Random.map2 (\k v -> (k, v)) randomString gen))

viewList : (a -> Html.Html msg) -> (List a -> Html.Html msg)
viewList f xs =
    Html.table []
     [Html.caption [] [Html.text "List"]
    , Html.tbody [] (List.indexedMap (\i x -> Html.tr [] [Html.td [] [Html.text <| String.fromInt i], Html.td [] [f x]]) xs)]

viewMaybe : (a -> Html.Html msg) -> (Maybe a -> Html.Html msg)
viewMaybe f m =
    case m of
      Nothing  ->
        Html.div [Html.Attributes.class "elm-derive-maybe"] [Html.text "null"]
      Just a ->
        Html.div [Html.Attributes.class "elm-derive-maybe"] [f a]

viewBool : Bool -> Html.Html msg
viewBool value =
    Html.div [Html.Attributes.class "elm-derive-primitive"] [Html.text <| if value then
      "True"
    else
      "False"]

viewInt : Int -> Html.Html msg
viewInt value =
    Html.div [Html.Attributes.class "elm-derive-primitive"] [Html.text <| String.fromInt value]

viewString : String -> Html.Html msg
viewString value =
    Html.div [Html.Attributes.class "elm-derive-primitive"] [Html.text value]

viewChar : Char -> Html.Html msg
viewChar value =
    Html.div [Html.Attributes.class "elm-derive-primitive"] [Html.text <| String.fromChar value]

viewFloat : Float -> Html.Html msg
viewFloat value =
    Html.div [Html.Attributes.class "elm-derive-primitive"] [Html.text <| String.fromFloat value]

viewDict : (a -> Html.Html msg) -> (Dict.Dict String a -> Html.Html msg)
viewDict f dict =
    Html.table []
     [Html.caption [] [Html.text "Dict"]
    , Html.tbody [] (List.map (\(k, v) -> Html.tr [] [Html.td [] [Html.text k], Html.td [] [f v]]) (Dict.toList dict))]

viewTuple : (a -> Html.Html msg) -> ((b -> Html.Html msg) -> ((a, b) -> Html.Html msg))
viewTuple fa fb (a, b) =
    Html.table []
     [Html.caption [] [Html.text "Dict"]
    , Html.tbody []
     [Html.tr []
     [Html.td [] [Html.text "fst"]
    , Html.td [] [fa a]]
    , Html.tr []
     [Html.td [] [Html.text "snd"]
    , Html.td [] [fb b]]]]